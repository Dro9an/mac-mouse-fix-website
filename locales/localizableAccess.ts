/*
This file provides convenience methods for accessing the autogenerated Localizable.js data from our vue components.

The main way to access Localizable.js is through the vuei18n framework. E.g. it lets you access translations with $t() (Update: Use MFLocalizedString() instead) or lets you access a list of locales with $coolI18n.localeCodes.
However we store some extra, custom data in Localizable.js which we make easy-to-access with this module.
*/

export { localeInfo, sourceLocale, localeCodes, progressDisplay, localizationProgressAsInt, _localizedString };

import Localizable from "./Localizable.js";

function localizationProgressAsInt(locale: string): number {
  
  // Returns the progress percentage as an int. E.g. if the locale is 56% translated, this returns 56.
  
  const progressStr = progressDisplay(locale);
  const result = parseInt(progressStr);

  console.assert(progressStr.charAt(progressStr.length-1) == '%');
  console.assert(2 <= progressStr.length && progressStr.length <= 4);
  console.assert(0 <= result && result <= 100);

  return result;
}

function progressDisplay(locale: string): string {
  // Handle isSourceLocale
  //  Note: Source language is 100% translated by definition.
  if (locale == sourceLocale()) {
    return "100%";
  }

  // Get info
  var info = localeInfo(locale);

  // Guard noInfo
  if (info == null) {
    console.assert(false);
    return "0%";
  }

  // Get result
  var result = info!.progressDisplay; // I think It would probably be cleaner if `info` gave us a float instead of a string like `%87`

  // Guard invalid result;
  if (result == null || !result.includes("%")) {
    console.assert(false);
    return "0%";
  }

  // Return
  return result;
}

const localeCodes = () => {
  // Note: Locales never change after building the app, and we use this a lot, so we could cache this. Maybe in a set for performance?
  return Localizable.locales.map(l => l.code)
}

function sourceLocale(): string {
  return Localizable["sourceLocale"];
}

function localeInfo(locale: string) {
  var result = null;

  for (var localeInfo of Localizable["locales"]) {
    if (localeInfo["code"] == locale) {
      result = localeInfo;
      break;
    }
  }

  return result;
}

function _localizedString(strKey: string, localeCode: string): string {

  /* When in doubt, use the wrapper (MFLocalizedString) instead */

  /* 
      This function gets a localized string directly from the Localizable.js file 
          We use this over $i18n.t() since that always strips {format_specifiers} from the string for some reason. And we wanna do the formatting ourselves in stringf(), 
          so that we can separate the string retrieval (MFLocalizedString()) out from the formatting (stringf()), while $i18n.t() does it all at once. 
          Separating this out has the benefit that we can easily regex the source files for MFLocalizedString() calls. 
          
          Note that this does not have reactivity, which I think $t() does. However, this doesn't seem to be a problem and locale switching seems to work flawlessly. Not sure why.
  */

  // Get locale code

  // Get translated string
  //  @ts-ignore
  var result: string|undefined = Localizable.strings[localeCode][strKey];

  // Make sure output is string - so we can use output directly in Vue templates without typescript complaining.
  if (typeof result !== 'string') {
      result = `<invalid localized string: ${objectDescription(result)} for key: ${strKey}>`;
  }

  // Return
  return result;
}
